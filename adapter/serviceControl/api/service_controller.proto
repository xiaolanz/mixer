// Copyright 2016 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

syntax = "proto3";

package adaptor.servicecontrol.api;

import "google/rpc/status.proto";
import "google/protobuf/duration.proto";
import "google/protobuf/any.proto";
import "google/protobuf/struct.proto";
import "google/protobuf/timestamp.proto";

// [Google Service Control API](/service-control/overview)
//
// Lets clients check and report operations against
// a [managed service][google.api.servicemanagement.v1.ManagedService].
service ServiceController {
  // Reports operations to Google Service Control. It should be called
  // after the operation is completed.
  //
  // If feasible, the client should aggregate reporting data for up to 5s to
  // reduce API traffic. Limiting aggregation to 5s is to reduce data loss
  // during client crashes. Clients should carefully choose the aggregation
  // window to avoid data loss risk more than 0.01% for business and
  // compliance reasons.
  //
  // This method requires the `servicemanagement.services.report` permission
  // on the specified service. For more information, see
  // [Google Cloud IAM](https://cloud.google.com/iam).
  rpc Report(ReportRequest) returns (ReportResponse) {
    option (google.api.http) = { post: "/v1/services/{service_name}:report" body: "*" };
  }
}

// Request message for the Report method.
message ReportRequest {
  // The service name as specified in its service configuration. For example,
  // `"pubsub.googleapis.com"`.
  //
  // See [google.api.Service][google.api.Service] for the definition of a service name.
  string service_name = 1;

  // Operations to be reported.
  //
  // Typically the service should report one operation per request.
  // Putting multiple operations into a single request is allowed, but should
  // be used only when multiple operations are natually available at the time
  // of the report.
  //
  // If multiple operations are in a single request, the total request size
  // should be no larger than 1MB. See [ReportResponse.report_errors][google.api.servicecontrol.v1.ReportResponse.report_errors] for
  // partial failure behavior.
  repeated Operation operations = 2;

  // Specifies which version of service config should be used to process the
  // request.
  //
  // If unspecified or no matching version can be found, the
  // latest one will be used.
  string service_config_id = 3;
}

// Response message for the Report method.
message ReportResponse {
  // Represents the processing error of one `Operation` in the request.
  message ReportError {
    // The [Operation.operation_id][google.api.servicecontrol.v1.Operation.operation_id] value from the request.
    string operation_id = 1;

    // Details of the error when processing the `Operation`.
    google.rpc.Status status = 2;
  }

  // Partial failures, one for each `Operation` in the request that failed
  // processing. There are three possible combinations of the RPC status:
  //
  // 1. The combination of a successful RPC status and an empty `report_errors`
  //    list indicates a complete success where all `Operations` in the
  //    request are processed successfully.
  // 2. The combination of a successful RPC status and a non-empty
  //    `report_errors` list indicates a partial success where some
  //    `Operations` in the request succeeded. Each
  //    `Operation` that failed processing has a corresponding item
  //    in this list.
  // 3. A failed RPC status indicates a complete failure where none of the
  //    `Operations` in the request succeeded.
  repeated ReportError report_errors = 1;

  // The actual config id used to process the request.
  string service_config_id = 2;
}

// Distribution represents a frequency distribution of double-valued sample
// points. It contains the size of the population of sample points plus
// additional optional information:
//
//   - the arithmetic mean of the samples
//   - the minimum and maximum of the samples
//   - the sum-squared-deviation of the samples, used to compute variance
//   - a histogram of the values of the sample points
message Distribution {
  // Describing buckets with constant width.
  message LinearBuckets {
    // The number of finite buckets. With the underflow and overflow buckets,
    // the total number of buckets is `num_finite_buckets` + 2.
    // See comments on `bucket_options` for details.
    int32 num_finite_buckets = 1;

    // The i'th linear bucket covers the interval
    //   [offset + (i-1) * width, offset + i * width)
    // where i ranges from 1 to num_finite_buckets, inclusive.
    // Must be strictly positive.
    double width = 2;

    // The i'th linear bucket covers the interval
    //   [offset + (i-1) * width, offset + i * width)
    // where i ranges from 1 to num_finite_buckets, inclusive.
    double offset = 3;
  }

  // Describing buckets with exponentially growing width.
  message ExponentialBuckets {
    // The number of finite buckets. With the underflow and overflow buckets,
    // the total number of buckets is `num_finite_buckets` + 2.
    // See comments on `bucket_options` for details.
    int32 num_finite_buckets = 1;

    // The i'th exponential bucket covers the interval
    //   [scale * growth_factor^(i-1), scale * growth_factor^i)
    // where i ranges from 1 to num_finite_buckets inclusive.
    // Must be larger than 1.0.
    double growth_factor = 2;

    // The i'th exponential bucket covers the interval
    //   [scale * growth_factor^(i-1), scale * growth_factor^i)
    // where i ranges from 1 to num_finite_buckets inclusive.
    // Must be > 0.
    double scale = 3;
  }

  // Describing buckets with arbitrary user-provided width.
  message ExplicitBuckets {
    // 'bound' is a list of strictly increasing boundaries between
    // buckets. Note that a list of length N-1 defines N buckets because
    // of fenceposting. See comments on `bucket_options` for details.
    //
    // The i'th finite bucket covers the interval
    //   [bound[i-1], bound[i])
    // where i ranges from 1 to bound_size() - 1. Note that there are no
    // finite buckets at all if 'bound' only contains a single element; in
    // that special case the single bound defines the boundary between the
    // underflow and overflow buckets.
    //
    // bucket number                   lower bound    upper bound
    //  i == 0 (underflow)              -inf           bound[i]
    //  0 < i < bound_size()            bound[i-1]     bound[i]
    //  i == bound_size() (overflow)    bound[i-1]     +inf
    repeated double bounds = 1;
  }

  // The total number of samples in the distribution. Must be >= 0.
  int64 count = 1;

  // The arithmetic mean of the samples in the distribution. If `count` is
  // zero then this field must be zero.
  double mean = 2;

  // The minimum of the population of values. Ignored if `count` is zero.
  double minimum = 3;

  // The maximum of the population of values. Ignored if `count` is zero.
  double maximum = 4;

  // The sum of squared deviations from the mean:
  //   Sum[i=1..count]((x_i - mean)^2)
  // where each x_i is a sample values. If `count` is zero then this field
  // must be zero, otherwise validation of the request fails.
  double sum_of_squared_deviation = 5;

  // The number of samples in each histogram bucket. `bucket_counts` are
  // optional. If present, they must sum to the `count` value.
  //
  // The buckets are defined below in `bucket_option`. There are N buckets.
  // `bucket_counts[0]` is the number of samples in the underflow bucket.
  // `bucket_counts[1]` to `bucket_counts[N-1]` are the numbers of samples
  // in each of the finite buckets. And `bucket_counts[N] is the number
  // of samples in the overflow bucket. See the comments of `bucket_option`
  // below for more details.
  //
  // Any suffix of trailing zeros may be omitted.
  repeated int64 bucket_counts = 6;

  // Defines the buckets in the histogram. `bucket_option` and `bucket_counts`
  // must be both set, or both unset.
  //
  // Buckets are numbered the the range of [0, N], with a total of N+1 buckets.
  // There must be at least two buckets (a single-bucket histogram gives
  // no information that isn't already provided by `count`).
  //
  // The first bucket is the underflow bucket which has a lower bound
  // of -inf. The last bucket is the overflow bucket which has an
  // upper bound of +inf. All other buckets (if any) are called "finite"
  // buckets because they have finite lower and upper bounds. As described
  // below, there are three ways to define the finite buckets.
  //
  //   (1) Buckets with constant width.
  //   (2) Buckets with exponentially growing widths.
  //   (3) Buckets with arbitrary user-provided widths.
  //
  // In all cases, the buckets cover the entire real number line (-inf,
  // +inf). Bucket upper bounds are exclusive and lower bounds are
  // inclusive. The upper bound of the underflow bucket is equal to the
  // lower bound of the smallest finite bucket; the lower bound of the
  // overflow bucket is equal to the upper bound of the largest finite
  // bucket.
  oneof bucket_option {
    // Buckets with constant width.
    LinearBuckets linear_buckets = 7;

    // Buckets with exponentially growing width.
    ExponentialBuckets exponential_buckets = 8;

    // Buckets with arbitrary user-provided width.
    ExplicitBuckets explicit_buckets = 9;
  }
}

// A common proto for logging HTTP requests. Only contains semantics
// defined by the HTTP specification. Product-specific logging
// information MUST be defined in a separate message.
message HttpRequest {
  // The request method. Examples: `"GET"`, `"HEAD"`, `"PUT"`, `"POST"`.
  string request_method = 1;

  // The scheme (http, https), the host name, the path and the query
  // portion of the URL that was requested.
  // Example: `"http://example.com/some/info?color=red"`.
  string request_url = 2;

  // The size of the HTTP request message in bytes, including the request
  // headers and the request body.
  int64 request_size = 3;

  // The response code indicating the status of response.
  // Examples: 200, 404.
  int32 status = 4;

  // The size of the HTTP response message sent back to the client, in bytes,
  // including the response headers and the response body.
  int64 response_size = 5;

  // The user agent sent by the client. Example:
  // `"Mozilla/4.0 (compatible; MSIE 6.0; Windows 98; Q312461; .NET CLR 1.0.3705)"`.
  string user_agent = 6;

  // The IP address (IPv4 or IPv6) of the client that issued the HTTP
  // request. Examples: `"192.168.1.1"`, `"FE80::0202:B3FF:FE1E:8329"`.
  string remote_ip = 7;

  // The IP address (IPv4 or IPv6) of the origin server that the request was
  // sent to.
  string server_ip = 13;

  // The referer URL of the request, as defined in
  // [HTTP/1.1 Header Field Definitions](http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html).
  string referer = 8;

  // The request processing latency on the server, from the time the request was
  // received until the response was sent.
  google.protobuf.Duration latency = 14;

  // Whether or not a cache lookup was attempted.
  bool cache_lookup = 11;

  // Whether or not an entity was served from cache
  // (with or without validation).
  bool cache_hit = 9;

  // Whether or not the response was validated with the origin server before
  // being served from cache. This field is only meaningful if `cache_hit` is
  // True.
  bool cache_validated_with_origin_server = 10;

  // The number of HTTP response bytes inserted into cache. Set only when a
  // cache fill was attempted.
  int64 cache_fill_bytes = 12;
}

// An individual log entry.
message LogEntry {
  // Required. The log to which this log entry belongs. Examples: `"syslog"`,
  // `"book_log"`.
  string name = 10;

  // The time the event described by the log entry occurred. If
  // omitted, defaults to operation start time.
  google.protobuf.Timestamp timestamp = 11;

  // The severity of the log entry. The default value is
  // `LogSeverity.DEFAULT`.
  LogSeverity severity = 12;

  // A unique ID for the log entry used for deduplication. If omitted,
  // the implementation will generate one based on operation_id.
  string insert_id = 4;

  // A set of user-defined (key, value) data that provides additional
  // information about the log entry.
  map<string, string> labels = 13;

  // The log entry payload, which can be one of multiple types.
  oneof payload {
    // The log entry payload, represented as a protocol buffer that is
    // expressed as a JSON object. You can only pass `protoPayload`
    // values that belong to a set of approved types.
    google.protobuf.Any proto_payload = 2;

    // The log entry payload, represented as a Unicode string (UTF-8).
    string text_payload = 3;

    // The log entry payload, represented as a structure that
    // is expressed as a JSON object.
    google.protobuf.Struct struct_payload = 6;
  }
}
// The severity of the event described in a log entry, expressed as one of the
// standard severity levels listed below.  For your reference, the levels are
// assigned the listed numeric values. The effect of using numeric values other
// than those listed is undefined.
//
// You can filter for log entries by severity.  For example, the following
// filter expression will match log entries with severities `INFO`, `NOTICE`,
// and `WARNING`:
//
//     severity > DEBUG AND severity <= WARNING
//
// If you are writing log entries, you should map other severity encodings to
// one of these standard levels. For example, you might map all of Java's FINE,
// FINER, and FINEST levels to `LogSeverity.DEBUG`. You can preserve the
// original severity level in the log entry payload if you wish.
enum LogSeverity {
  // (0) The log entry has no assigned severity level.
  DEFAULT = 0;

  // (100) Debug or trace information.
  DEBUG = 100;

  // (200) Routine information, such as ongoing status or performance.
  INFO = 200;

  // (300) Normal but significant events, such as start up, shut down, or
  // a configuration change.
  NOTICE = 300;

  // (400) Warning events might cause problems.
  WARNING = 400;

  // (500) Error events are likely to cause problems.
  ERROR = 500;

  // (600) Critical events cause more severe problems or outages.
  CRITICAL = 600;

  // (700) A person must take an action immediately.
  ALERT = 700;

  // (800) One or more systems are unusable.
  EMERGENCY = 800;
}
// Represents a single metric value.
message MetricValue {
  // The labels describing the metric value.
  // See comments on [google.api.servicecontrol.v1.Operation.labels][google.api.servicecontrol.v1.Operation.labels] for
  // the overriding relationship.
  map<string, string> labels = 1;

  // The start of the time period over which this metric value's measurement
  // applies. The time period has different semantics for different metric
  // types (cumulative, delta, and gauge). See the metric definition
  // documentation in the service configuration for details.
  google.protobuf.Timestamp start_time = 2;

  // The end of the time period over which this metric value's measurement
  // applies.
  google.protobuf.Timestamp end_time = 3;

  // The value. The type of value used in the request must
  // agree with the metric definition in the service configuration, otherwise
  // the MetricValue is rejected.
  oneof value {
    // A boolean value.
    bool bool_value = 4;

    // A signed 64-bit integer value.
    int64 int64_value = 5;

    // A double precision floating point value.
    double double_value = 6;

    // A text string value.
    string string_value = 7;

    // A distribution value.
    Distribution distribution_value = 8;
  }
}

// Represents a set of metric values in the same metric.
// Each metric value in the set should have a unique combination of start time,
// end time, and label values.
message MetricValueSet {
  // The metric name defined in the service configuration.
  string metric_name = 1;

  // The values in this metric.
  repeated MetricValue metric_values = 2;
}
// Represents information regarding an operation.
message Operation {
  // Defines the importance of the data contained in the operation.
  enum Importance {
    // The API implementation may cache and aggregate the data.
    // The data may be lost when rare and unexpected system failures occur.
    LOW = 0;

    // The API implementation doesn't cache and aggregate the data.
    // If the method returns successfully, it's guaranteed that the data has
    // been persisted in durable storage.
    HIGH = 1;
  }

  // Identity of the operation. This must be unique within the scope of the
  // service that generated the operation. If the service calls
  // Check() and Report() on the same operation, the two calls should carry
  // the same id.
  //
  // UUID version 4 is recommended, though not required.
  // In scenarios where an operation is computed from existing information
  // and an idempotent id is desirable for deduplication purpose, UUID version 5
  // is recommended. See RFC 4122 for details.
  string operation_id = 1;

  // Fully qualified name of the operation. Reserved for future use.
  string operation_name = 2;

  // Identity of the consumer who is using the service.
  // This field should be filled in for the operations initiated by a
  // consumer, but not for service-initiated operations that are
  // not related to a specific consumer.
  //
  // This can be in one of the following formats:
  //   project:<project_id>,
  //   project_number:<project_number>,
  //   api_key:<api_key>.
  string consumer_id = 3;

  // Required. Start time of the operation.
  google.protobuf.Timestamp start_time = 4;

  // End time of the operation.
  // Required when the operation is used in [ServiceController.Report][google.api.servicecontrol.v1.ServiceController.Report],
  // but optional when the operation is used in [ServiceController.Check][google.api.servicecontrol.v1.ServiceController.Check].
  google.protobuf.Timestamp end_time = 5;

  // Labels describing the operation. Only the following labels are allowed:
  //
  // - Labels describing monitored resources as defined in
  //   the service configuration.
  // - Default labels of metric values. When specified, labels defined in the
  //   metric value override these default.
  // - The following labels defined by Google Cloud Platform:
  //     - `cloud.googleapis.com/location` describing the location where the
  //        operation happened,
  //     - `servicecontrol.googleapis.com/user_agent` describing the user agent
  //        of the API request,
  //     - `servicecontrol.googleapis.com/service_agent` describing the service
  //        used to handle the API request (e.g. ESP),
  //     - `servicecontrol.googleapis.com/platform` describing the platform
  //        where the API is served (e.g. GAE, GCE, GKE).
  map<string, string> labels = 6;

  // Represents information about this operation. Each MetricValueSet
  // corresponds to a metric defined in the service configuration.
  // The data type used in the MetricValueSet must agree with
  // the data type specified in the metric definition.
  //
  // Within a single operation, it is not allowed to have more than one
  // MetricValue instances that have the same metric names and identical
  // label value combinations. If a request has such duplicated MetricValue
  // instances, the entire request is rejected with
  // an invalid argument error.
  repeated MetricValueSet metric_value_sets = 7;

  // Represents information to be logged.
  repeated LogEntry log_entries = 8;

  // DO NOT USE. This is an experimental field.
  Importance importance = 11;
}
